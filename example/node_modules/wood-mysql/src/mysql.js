// mysql操作方法类
// by YuRonghui 2018-7-9
//const Query = require('wood-querysql');
const Sequelize = require('sequelize');
//const { Util } = require('wood-util')();
//const { error, catchErr } = Util;
let dbs = {};

class Mysql {
  constructor(tbName, dbName = 'master') {
    this.tableName = tbName;
    this.dbName = dbName;
    if (dbs[this.dbName]) {
      this.db = dbs[this.dbName];
    } else {
      throw error('mysql failed: db=null');
    }
  }
  // 创建数据库连接池
  static async connect(opts, name = 'master') {
    if (dbs[name]) {
      console.error(`Mysql connect ${name} already exsit!`);
      return;
    }
    let { database, user, password, ...options } = opts;
    options.dialect = 'mysql';
    try {
      dbs[name] = new Sequelize(database, user, password, options);
    } catch (error) {
      console.log(error);
    }
    console.log('Mysql connected Successfull');
  }

  define(tableName, opts) {
    return this.getConn().define(tableName, opts);
  }

  createTable(tableName, options) {
    return this.getTable(tableName).sync(options);
  }

  dropTable(tableName) {
    return this.getTable(tableName).drop(options);
  }

  getTable(tableName) {
    return this.getConn().models[tableName];
  }

  /**
   * Builds a new model instance and calls save on it.
   * @see {Instance#build}
   * @see {Instance#save}
   *
   * @param {Object}        values
   * @param {Object}        [options]
   * @param {Boolean}       [options.raw=false] If set to true, values will ignore field and virtual setters.
   * @param {Boolean}       [options.isNewRecord=true]
   * @param {Boolean}       [options.isDirty=true]
   * @param {Array}         [options.fields] If set, only columns matching those in fields will be saved
   * @param {Array}         [options.include] an array of include options - Used to build prefetched/included model instances
   * @param {String}        [options.onDuplicate]
   * @param {Transaction}   [options.transaction]
   *
   * @return {Promise<Instance>}
   */
  create(tableName, values, options) {
    return this.getTable(tableName).create(values, options);
  }

  findById(tableName, id) {
    return this.getTable(tableName).findById(id);
  }

  all(tableName, options, queryOptions) {
    return this.getTable(tableName).findAll(options, queryOptions);
  }
   /*
  * @param  {Object}                   [options] A hash of options to describe the scope of the search
   * @param  {Object}                  [options.where] A hash of attributes to describe your search. See above for examples.
   * @param  {Array<String>}           [options.attributes] A list of the attributes that you want to select. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as `Sequelize.literal`, `Sequelize.fn` and so on), and the second is the name you want the attribute to have in the returned instance
   * @param  {Boolean}                   [options.paranoid=true] If false, will include columns which have a non-null deletedAt column.
   * @param  {Array<Object|Model>}       [options.include] A list of associations to eagerly load using a left join. Supported is either `{ include: [ Model1, Model2, ...]}` or `{ include: [{ model: Model1, as: 'Alias' }]}`. If your association are set up with an `as` (eg. `X.hasMany(Y, { as: 'Z }`, you need to specify Z in the as attribute when eager loading Y).
   * @param  {Model}                     [options.include[].model] The model you want to eagerly load
   * @param  {String}                    [options.include[].as] The alias of the relation, in case the model you want to eagerly load is aliassed. For `hasOne` / `belongsTo`, this should be the singular name, and for `hasMany`, it should be the plural
   * @param  {Association}               [options.include[].association] The association you want to eagerly load. (This can be used instead of providing a model/as pair)
   * @param  {Object}                    [options.include[].where] Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set `required: false`
   * @param  {Array<String>}             [options.include[].attributes] A list of attributes to select from the child model
   * @param  {Boolean}                   [options.include[].required] If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if `include.where` is set, false otherwise.
   * @param  {Array<Object|Model>}       [options.include[].include] Load further nested related models
   * @param  {String|Array|Sequelize.fn} [options.order] Specifies an ordering. If a string is provided, it will be esacped. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: `order: [['name', 'DESC']]`. In this way the column will be escaped, but the direction will not.
   * @param  {Number}                    [options.limit]
   * @param  {Number}                    [options.offset]
   * @param  {Transaction}               [options.transaction]
   * @param  {Object}                    [queryOptions] Set the query options, e.g. raw, specifying that you want raw data instead of built Instances. See sequelize.query for options
   * @param  {String}                    [queryOptions.lock] Lock the selected rows in either share or update mode. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. See [transaction.LOCK for an example](https://github.com/sequelize/sequelize/wiki/API-Reference-Transaction#LOCK)
   */
   findAll(tableName, options, queryOptions) {
    return this.getTable(tableName).findAll(options, queryOptions);
  }

  findAllJoin(table, joinTable, options, queryOptions) {
    return this.getTable(tableName).findAllJoin(joinTable, options, queryOptions);
  }

  find(tableName, options) {
    return this.getTable(tableName).find(options);
  }

  findOne(tableName, options, queryOptions) {
    return this.getTable(tableName).findOne(options, queryOptions);
  }

  aggregate(tableName, field, aggreateFunction, options) {
    return this.getTable(tableName).aggregate(field, aggreateFunction, options);
  }

  count(tableName, options) {
    return this.getTable(tableName).count(options);
  }

  findAndCount(tableName, findOptions, queryOptions) {
    return this.getTable(tableName).findAndCount(findOptions, queryOptions);
  }

  findOrCreate(tableName, options, queryOptions) {
    return this.getTable(tableName).findOrCreate(options, queryOptions);
  }

  insertOrUpdate(tableName, values, options) {
    return this.getTable(tableName).insertOrUpdate(values, options);
  }

  delete(tableName, options) {
    return this.getTable(tableName).destroy(options);
  }

  /**
   * Update multiple instances that match the where options. The promise returns an array with one or two elements. The first element is always the number
   * of affected rows, while the second element is the actual affected rows (only supported in postgres with `options.returning` true.)
   *
   * @param  {Object}       values
   * @param  {Object}       options
   * @param  {Object        options.where                   Options to describe the scope of the search.
   * @param  {Boolean}      [options.validate=true]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation
   * @param  {Boolean}      [options.hooks=true]            Run before / after bulk update hooks?
   * @param  {Boolean}      [options.individualHooks=false] Run before / after update hooks?
   * @param  {Boolean}      [options.returning=false]       Return the affected rows (only for postgres)
   * @param  {Number}       [options.limit]                 How many rows to update (only for mysql and mariadb)
   * @param  {Transaction}  [options.transaction]
   *
   * @return {Promise<Array<affectedCount,affectedRows>>}
   */
  update(tableName, values, options) {
    return this.getTable(tableName).update(values, options);
  }

  query(sql, options) {
    return this.getConn().query(sql, options);
  }
  // 获取连接
  getConn(database) {
    return dbs[database || this.dbName];
  }
}

module.exports = Mysql;
