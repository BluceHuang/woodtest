// mysql操作方法类
// by bluchuang 2018-11-9
const Sequelize = require('sequelize');
let dbs = {};

class Mysql {
  constructor(tbName, dbName = 'master') {
    this.tableName = tbName;
    this.dbName = dbName;
    if (dbs[this.dbName]) {
      this.db = dbs[this.dbName];
    } else {
      throw error('mysql failed: db=null');
    }
  }
  // 创建数据库连接池
  static async connect(opts, name = 'master') {
    if (dbs[name]) {
      console.error(`Mysql connect ${name} already exsit!`);
      return;
    }
    let { database, user, password, ...options } = opts;
    options.dialect = 'mysql';
    try {
      dbs[name] = new Sequelize(database, user, password, options);
    } catch (error) {
      console.log(error);
    }
    console.log('Mysql connected Successfull');
  }

  sync(tableName) {
    return this.getTable(tableName).sync();
  }

  define(tableName, columns) {
    let options = {freezeTableName: true, timestamps: false};
    return this.getConn().define(tableName, columns, options);
  }

  createTable(tableName, options) {
    return this.getTable(tableName).sync(options);
  }

  dropTable(tableName) {
    return this.getTable(tableName).drop(options);
  }

  getTable(tableName) {
    return this.getConn().models[tableName];
  }

  /**
   * Builds a new model instance and calls save on it.
   * @see {Instance#build}
   * @see {Instance#save}
   *
   * @param {Object}        values
   * @param {Object}        [options]
   * @param {Boolean}       [options.raw=false] If set to true, values will ignore field and virtual setters.
   * @param {Boolean}       [options.isNewRecord=true]
   * @param {Boolean}       [options.isDirty=true]
   * @param {Array}         [options.fields] If set, only columns matching those in fields will be saved
   * @param {Array}         [options.include] an array of include options - Used to build prefetched/included model instances
   * @param {String}        [options.onDuplicate]
   * @param {Transaction}   [options.transaction]
   *
   * @return {Promise<Instance>}
   */
  create(tableName, values, options) {
    return this.getTable(tableName).create(values, options);
  }

  findById(tableName, id) {
    return this.getTable(tableName).findById(id);
  }

  all(tableName, options, queryOptions) {
    return this.getTable(tableName).findAll(options, queryOptions);
  }
   /*
  * @param  {Object}                   [options] A hash of options to describe the scope of the search
   * @param  {Object}                  [options.where] A hash of attributes to describe your search. See above for examples.
   * @param  {Array<String>}           [options.attributes] A list of the attributes that you want to select. To rename an attribute, you can pass an array, with two elements - the first is the name of the attribute in the DB (or some kind of expression such as `Sequelize.literal`, `Sequelize.fn` and so on), and the second is the name you want the attribute to have in the returned instance
   * @param  {Boolean}                   [options.paranoid=true] If false, will include columns which have a non-null deletedAt column.
   * @param  {Array<Object|Model>}       [options.include] A list of associations to eagerly load using a left join. Supported is either `{ include: [ Model1, Model2, ...]}` or `{ include: [{ model: Model1, as: 'Alias' }]}`. If your association are set up with an `as` (eg. `X.hasMany(Y, { as: 'Z }`, you need to specify Z in the as attribute when eager loading Y).
   * @param  {Model}                     [options.include[].model] The model you want to eagerly load
   * @param  {String}                    [options.include[].as] The alias of the relation, in case the model you want to eagerly load is aliassed. For `hasOne` / `belongsTo`, this should be the singular name, and for `hasMany`, it should be the plural
   * @param  {Association}               [options.include[].association] The association you want to eagerly load. (This can be used instead of providing a model/as pair)
   * @param  {Object}                    [options.include[].where] Where clauses to apply to the child models. Note that this converts the eager load to an inner join, unless you explicitly set `required: false`
   * @param  {Array<String>}             [options.include[].attributes] A list of attributes to select from the child model
   * @param  {Boolean}                   [options.include[].required] If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if `include.where` is set, false otherwise.
   * @param  {Array<Object|Model>}       [options.include[].include] Load further nested related models
   * @param  {String|Array|Sequelize.fn} [options.order] Specifies an ordering. If a string is provided, it will be esacped. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: `order: [['name', 'DESC']]`. In this way the column will be escaped, but the direction will not.
   * @param  {Number}                    [options.limit]
   * @param  {Number}                    [options.offset]
   * @param  {Transaction}               [options.transaction]
   * @param  {Object}                    [queryOptions] Set the query options, e.g. raw, specifying that you want raw data instead of built Instances. See sequelize.query for options
   * @param  {String}                    [queryOptions.lock] Lock the selected rows in either share or update mode. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. See [transaction.LOCK for an example](https://github.com/sequelize/sequelize/wiki/API-Reference-Transaction#LOCK)
   */
   findAll(tableName, options = {}, queryOptions) {
    if (!options.where) {
      options = {where: options};
    };

    options.raw = true;
    return new Promise((resolve, reject) => {
      this.getTable(tableName).findAll(options, queryOptions).then(data => {
        resolve(data);   
      });
    })
  }

  // findAllJoin(table, joinTable, options, queryOptions) {
  //   if (!options.where) {
  //     options = {where: options};
  //   };
  //   return new Promise((resolve, reject) => {
  //     this.getTable(tableName).findAllJoin(joinTable, options, queryOptions).then(data => {
  //       let result = data.map(item=>item.dataValues);
  //       resolve(result);   
  //     });
  //   });
  // }

  find(tableName, options = {}) {
    if (!options.where) {
      options = {where: options};
    };

    options.raw = true;
    return new Promise((resolve, reject) => {
      this.getTable(tableName).find(options).then(data => {
        if (data === null) {
          resolve({});
        }else {
          resolve(data)
        }   
      });
    })
  }

  /** 
   * Project.findOne({
  where: {title: 'aProject'},
  attributes: ['id', ['name', 'title']]
  }).then(project => {
  // project 将是 Projects 表中 title 为 'aProject'  的第一个条目 || null
  // project.title 将包含 project 的 name
  })
  */
  findOne(tableName, options = {}, queryOptions) {
    if (!options.where) {
      options = {where: options};
    };

    options.raw = true;
    return new Promise((resolve, reject) => {
      this.getTable(tableName).findOne(options, queryOptions).then(data => {
        if (data === null) {
          resolve({});
        }else {
          resolve(data)
        }
      });
    });
  }

  aggregate(tableName, field, aggreateFunction, options) {
    return this.getTable(tableName).aggregate(field, aggreateFunction, options);
  }

  count(tableName, options) {
    return this.getTable(tableName).count(options);
  }

  /**
   * return {count, rows[instance info]}
   */
  findAndCount(tableName, findOptions, queryOptions) {
    if (!findOptions.where) {
      findOptions = {where: findOptions};
    };
    return this.getTable(tableName).findAndCount(findOptions, queryOptions);
  }

  findOrCreate(tableName, options, queryOptions) {
    return new Promise((resolve, reject) => {
      this.getTable(tableName).findOrCreate(options, queryOptions).spread((data, created)=> {
        resolve(data.dataValues);
      });
    });
  }

  insertOrUpdate(tableName, values, options) {
    return this.getTable(tableName).insertOrUpdate(values, options);
  }

  // return delete row number
  delete(tableName, options) {
    return this.getTable(tableName).destroy(options);
  }

  /**
   * Update multiple instances that match the where options. The promise returns an array with one or two elements. The first element is always the number
   * of affected rows, while the second element is the actual affected rows (only supported in postgres with `options.returning` true.)
   *
   * @param  {Object}       values
   * @param  {Object}       options
   * @param  {Object        options.where                   Options to describe the scope of the search.
   * @param  {Boolean}      [options.validate=true]         Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation
   * @param  {Boolean}      [options.hooks=true]            Run before / after bulk update hooks?
   * @param  {Boolean}      [options.individualHooks=false] Run before / after update hooks?
   * @param  {Boolean}      [options.returning=false]       Return the affected rows (only for postgres)
   * @param  {Number}       [options.limit]                 How many rows to update (only for mysql and mariadb)
   * @param  {Transaction}  [options.transaction]
   *
   * @return {Promise<Array<affectedCount,affectedRows>>}
   */
  update(tableName, options = {}, values) {
    if (!options.validate) options['validate'] = true;
    return this.getTable(tableName).update(values, options);
  }

  bulkCreate(tableName, records, options = {}) {
    if (!options.validate) options['validate'] = true;
    
    return new Promise((resolve, reject) => {
      this.getTable(tableName).bulkCreate(records, options).then(data => {
        let result = data.map(item=>item.dataValues);
        resolve(result);   
      });
    });
  }

  /*
    options.type   eg: Sequelize QueryTypes.SELECT
    options.model  eg: model name, return specific model instant

    sequelize.query('SELECT * FROM projects WHERE status = ?',
    { replacements: ['active'], type: sequelize.QueryTypes.SELECT }
    ).then(projects => {
      console.log(projects)
    })

    sequelize.query('SELECT * FROM projects WHERE status = :status ',
    { replacements: { status: 'active' }, type: sequelize.QueryTypes.SELECT }
    ).then(projects => {
      console.log(projects)
    })
  */
  query(sql, options) {
    return this.getConn().query(sql, options);
  }
  // 获取连接
  getConn(database) {
    return dbs[database || this.dbName];
  }

  hasOne(name) {
    this.getTable(this.tableName).hasOne(this.getTable(name));
  }

  belongsTo(name) {
    this.getTable(this.tableName).belongsTo(this.getTable(name));
  }

  hasMany(name) {
    this.getTable(this.tableName).hasMany(this.getTable(name));
  }

  belongsToMany(name) {
    this.getTable(this.tableName).belongsToMany(this.getTable(name));
  }

  // 托管提交事务，在回调里处理查询更新操作，如需回滚在回调中抛出异常即可，callback带一个事务参数
  transaction(options = {}, callback) {
    return this.getConn().transaction(options, callback);
  }
}

module.exports = Mysql;
