// 数据模型基类
// by bluchhuang 2018-11-23
const { Util } = require('wood-util')();
let largelimit = 20000; //限制不能超过2万条数据返回
const _timeout = 0;
const _KeyTimeout = 60 * 1; //设置listkey过期时间，秒

class Model {
  constructor(opts = {}) {
    this.tableName = opts.tableName;
    this.options = opts.options;
    this.ctx = opts.ctx;
    this.data = {};
    this.associateOptions = opts.associateOptions;
  }

  async _init() {
    this.model = this.db.define(this.tableName, this.options);
    await this.model.sync();
    if (this.associateOptions) {
      for (let item in this.associateOptions) {
        if (typeof this.db[item] === 'function') {
          this.db[item](this.associateOptions[item]);
        }
      }
    }
  }

  // 重置数据
  resetData() {
    this.data = {};
  }

  // 设置数据
  setData(target, value) {
    if (!value && typeof(target) === 'object' && !Array.isArray(target)) {
      this.data = target;
    } else {
      try {
        let dataValue = {};
        dataValue[target] = value;
        Object.assign(this.data, dataValue);
      } catch (err) {
        console.log(err);
      }
    }
  }

  // 获取模型数据
  getData(hasVirtualField = true) {
    return this.data;
  }

  // 是否新的
  isNew() {
    return !this.data.id;
  }

  //新增数据
  async create(data = {}, addLock = false) {
    const { catchErr, error } = this.ctx;
    if (!data) throw error('create方法的参数data不能为空');
    if(!Util.isEmpty(data)) this.setData(data);
    const lock = addLock ? await catchErr(this.redis.lock()) : {data: 1};
    if (lock.data) {
      let result = await catchErr(this.db.create(this.tableName, this.getData()));
      if(addLock) this.redis.unlock(lock.data);
      if(result.err) throw error(result.err);
      return result.data;
    } else {
      throw error(lock.err);
    }
  }

  // 更新数据
  async update(data = {}, addLock = false, isFindOneAndUpdate = false) {
    const { catchErr, error } = this.ctx;
    if (!data) throw error('update方法的参数data不能为空');
    if(!Util.isEmpty(data)) this.setData(data);
    if (!this.data.id && !this.data.where) throw error('缺少id key或者查询条件，不能更新');
    
    let id = this.data.id;
    let where = this.data.where;
    if (!where) {
      where = {'where':{id}};
      delete this.data.id;
    } else {
      where = {where};
      delete this.data.where;
    }
    
    let lock = addLock ? await catchErr(this.redis.lock()) : {'data': 1};
    if (lock.data) {
      if (isFindOneAndUpdate) where.limit = 1;
      const result = await catchErr(this.db.update(this.tableName, where, this.getData()));
      if(addLock) this.redis.unlock(lock.data);
      if (result.data){
        return result.data[0] ? this.data : {};
      }else{
        throw error(result.err);
      }
    }
  }

  // 更新数据, 结果返回当前记录
  async findOneAndUpdate(data = {}, addLock = true) {
    return this.update(data, addLock, true);
  }

  // 保存数据
  async save() {
    const { catchErr, error } = this.ctx;
    let data = this.getData(false);
    if (Util.isEmpty(data) || !data) throw error('save方法的data为空');
    if (!this.isNew() || data.id) {
      const updateOk = await catchErr(this.db.update(this.tableName, data));
      if (updateOk.err) throw error(updateOk.err);
      return updateOk.data;
    } else {
      const result = await catchErr(this.db.create(this.tableName, data));
      if (result.err) throw error(result.err);
      return result.data;
    }
  }

  //删除数据
  async remove(options) {
    const { catchErr, error } = this.ctx;
    if (!data) return false;
    const lock = await catchErr(this.redis.lock());
    if (lock.err) {
      throw error(lock.err);
    }else{
      return this.db.delete(this.tableName, options);
    }
  }

  //清空数据
  async clear() {
    const { catchErr, error } = this.ctx;
    const lock = await catchErr(this.redis.lock());
    if (lock.err) {
      throw error(lock.err);
    }else{
      return this.db.delete(this.tableName, {});
    }
  }

  // 执行查询
  async exec(sql, options) {
    const { catchErr, error } = this.ctx;
    let result = await catchErr(this.db.query(sql, options));
    if (result.err) {
      throw error(result.err);
    } else {
      return result.data;
    }
  }

  // 条件查询
  async find(data, addLock = false) {
    const { catchErr, error } = this.ctx;
    const hasLock = addLock ? await catchErr(this.redis.hasLock()) : {};
    if(hasLock.err){
      throw error(hasLock.err);
    }else{
      if (!hasLock.data) {
        let result = await catchErr(this.db.find(this.tableName, data));
        if(result.err){
          throw error(result.err);
        }else{
          return Array.isArray(result.data) ? result.data : [result.data];
        }
      } else {
        await new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve(true);
          }, _timeout);
        });
        return this.findOne(data, addLock);
      }
    }
  }

  // 查询单条记录
  async findOne(data, addLock = false) {
    const { catchErr, error } = this.ctx;
    const hasLock = addLock ? await catchErr(this.redis.hasLock()) : {};
    if(hasLock.err){
      throw error(hasLock.err);
    }else{
      if (!hasLock.data) {
        let result = await catchErr(this.db.findOne(this.tableName, data));
        if(result.err){
          throw error(result.err);
        }else{
          return Array.isArray(result.data) ? result.data[0] : result.data;
        }
      } else {
        await new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve(true);
          }, _timeout);
        });
        return this.findOne(data, addLock);
      }
    }
  }

  // 可实现分页查询
  /* @param {object} [params] find condition
   * @param {boolean} [hasCahche] cache result in redis or not
   * @param {string} [keynName] specify key name for cache result
   * @param {number} [opts.limit] per page limit
   * @param {number} [opts.page] current page number
   * @param {number} [opts.largepage] large page number, per large page has largelimit number
  */
  async findList(params = {}, hasCache = true, keyName = '', opts = {}, addLock = false) {
    const { catchErr, error } = this.ctx;
    if (!params) throw error('findList方法参数data不能为空');
    let hasLock = addLock ? await catchErr(this.redis.hasLock()) : {};
    if(hasLock.err){
      throw error(hasLock.err);
    }else{
      if (!hasLock.data) {
        if (hasCache) {
          let listKey = '', hasKey = false, largepage = 1;
          let limit = opts.limit == undefined ? 20 : Number(opts.limit);
          let page = opts.page || 1;
          largepage = opts.largepage || 1;
          page = page % Math.ceil(largelimit / limit) || 1;
          listKey = keyName || this.getListKey(params); //生成listkey
          hasKey = await this.redis.existKey(listKey); //key是否存在 
          if (hasKey) {
            let startIndex = (page - 1) * limit;
            let ids = await this.redis.listSlice(listKey, startIndex, startIndex + limit - 1);
            ids = ids.map(item => parseInt(item));
            
            let where = {where: {id: ids}};
            let result = await catchErr(this.db.findAll(this.tableName, where));
            if (result.err) {
              throw error(result.err);
            } else {
              return {
                count: Number(result.data.length),
                list: result.data
              };
            }
          }
        }
        
        let where = {};
        if (params.where) {
          where = params;
          where.limit = largelimit;
        } else {
          where = {'where': where, 'limit': largelimit};    
        }

        const docsResult = await catchErr(this.db.findAll(this.tableName, where));
        if (docsResult.err) {
          throw error(docsResult.err);
        }else{
          let docs = docsResult.data;
          if (hasCache && docs.length) {
            if (docs.length >= largelimit) {
              largepage = largepage || 1;
              let startNum = (largepage - 1) * largelimit;
              docs = docs.slice(startNum, startNum + largelimit);
            }
            let listKey = keyName || this.getListKey(params);
            await this.redis.listPush(listKey, docs.map(item => item.id));
            this.redis.setKeyTimeout(listKey, _KeyTimeout); //设置listkey一小时后过期
            return {
              count: Number(docs.length),
              list: docs || []
            };
          }
        }
      }else{
        await new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve(true);
          }, _timeout);
        });
        return this.findList(data, hasCache, keyName, opts, addLock);
      }
    }
  }

  getListKey(params = {}) {
    if (params.data) {
      if (params.data.limit) delete params.data.limit;
      if (params.data.page) delete params.data.page;
    }

    let body = JSON.stringify(params);
    return Util.md5(body);
  }

  // 托管提交事务，在回调里处理查询更新操作，如需回滚在回调中抛出异常即可，callback带一个事务参数
  transaction(options = {}, callback) {
    return this.db.transaction(options, callback);
  }
}

module.exports = Model;
